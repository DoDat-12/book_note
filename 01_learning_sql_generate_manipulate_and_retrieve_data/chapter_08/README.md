# Chapter 8. Grouping and Aggregates

## Grouping Concepts

    SELECT customer_id, count(*) -- aggregate function: count
    FROM rental
    GROUP BY customer_id;

The aggregate function `count()` counts the number of rows in each group, and the asterisk tells the server to count
everything in the group

> You cannot refer to the aggregate function count(*) in your where clause, because the groups have not yet been
> generated at the time the where clause is evaluated. Instead, you must put your group filter conditions in the having
> clause

    SELECT customer_id, count(*)
    FROM rental
    GROUP BY customer_id
    HAVING count(*) >= 40;

## Aggregate Functions

`max()` - returns the maximum value within a set
`min()` - returns the minimum value within a set
`avg()` - returns the average value across a set
`sum()` - returns the sum of the values across a set
`count()` - returns the number of the values in a set

    SELECT MAX(amount) max_amt,
        MIN(amount) min_amt,
        AVG(amount) avg_amt,
        SUM(amount) tot_amt,
        COUNT(*) num_payments
    FROM payment;

### Implicit Versus Explicit Groups

_Implicit_ group: There is no `group by` clause, aggregate function on all rows in the `payment` table

_Explicit_ group: In some case want to retrieve additional columns along with columns generated by aggregate functions.
So you need to add a `group by` clause to specify over which group of rows the aggregate functions should be applied

    SELECT customer_id,
        MAX(amount) max_amt,
        MIN(amount) min_amt,
        AVG(amount) avg_amt,
        SUM(amount) tot_amt,
        COUNT(*) num_payments
    FROM payment
    GROUP BY customer_id;

### Counting Distinct Values

    SELECT COUNT(customer_id) num_rows,
        COUNT(DISTINCT customer_id) num_customers
    FROM payment;

### Using Expressions

    SELECT MAX(datediff(return_date, rental_date))
    FROM rental;

### How Nulls Are Handled

Only `count(*)` counts the number of rows (include rows have null values), `count(val)` counts the number of _values_
contained in the `val` column and ignores any `null` values encountered (same with `sum()`, `max()`, `avg()`)

## Generating Groups

### Single-Column Grouping

    SELECT actor_id, count(*)
    FROM film_actor
    GROUP BY actor_id

### Multicolumn Grouping

    SELECT fa.actor_id, f.rating, count(*)
    FROM film_actor fa
        INNER JOIN film f
        ON fa.film_id = f.film_id
    GROUP BY fa.actor_id, f.rating
    ORDER BY 1, 2;

### Grouping via Expressions

    SELECT extract(YEAR FROM rental_date) year,
        COUNT(*) how_many
    FROM rental
    GROUP BY extract(YEAR FROM rental_date);

### Generating Rollups

From example in **Multicolumn Grouping**, counts the number of films for each actor and film rating. You also want total
counts for each distinct actor (ignore rating)

    SELECT fa.actor_id, f.rating, count(*)
    FROM film_actor fa
        INNER JOIN film f
        ON fa.film_id = f.film_id
    GROUP BY fa.actor_id, f.rating WITH ROLLUP -- ignore rating to count() for actor_id
    ORDER BY 1, 2;

    +----------+--------+----------+
    | actor_id | rating | count(*) |
    +----------+--------+----------+
    |     NULL | NULL   |     5462 |
    |        1 | NULL   |       19 | -- addtion because of rollup
    |        1 | G      |        4 |
    |        1 | PG     |        6 |
    |        1 | PG-13  |        1 |
    |        1 | R      |        3 |
    |        1 | NC-17  |        5 |
    |        2 | NULL   |       25 |
    |        2 | G      |        7 |

> A `null` value is provided for the rating column, since the **rollup** is being performed across all **ratings**

## Group Filter Conditions

When grouping data, you also can apply filter conditions to the data _after_ the groups have been generated.
The `having` clause is where you should place these types of filter condition

    SELECT fa.actor_id, f.rating, count(*)
    FROM film_actor fa
        INNER JOIN film f
        ON fa.film_id = f.film_id
    WHERE f.rating IN ('P', 'PG')
    GROUP BY fa.actor_id, f.rating
    HAVING count(*) > 9;

This query has 2 filter: one (`where` clause) acts on data _before_ it is grouped, and the other (`having` clause) acts
on data _after_ the groups have been created
